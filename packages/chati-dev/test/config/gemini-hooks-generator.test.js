/**
 * @fileoverview Tests for config/gemini-hooks-generator module.
 *
 * Validates that Gemini CLI hooks are correctly generated with proper
 * event mappings, valid JavaScript, and no Claude-specific references.
 */

import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { HOOK_MAP, generateAllGeminiHooks, generateGeminiSettings } from '../../src/config/gemini-hooks-generator.js';

// ---------------------------------------------------------------------------
// HOOK_MAP
// ---------------------------------------------------------------------------

describe('HOOK_MAP', () => {
  it('has 6 entries', () => {
    assert.equal(Object.keys(HOOK_MAP).length, 6);
  });

  it('maps prism-engine to BeforeModel', () => {
    assert.equal(HOOK_MAP['prism-engine'].event, 'BeforeModel');
  });

  it('maps model-governance to BeforeModel', () => {
    assert.equal(HOOK_MAP['model-governance'].event, 'BeforeModel');
  });

  it('maps mode-governance to BeforeTool', () => {
    assert.equal(HOOK_MAP['mode-governance'].event, 'BeforeTool');
  });

  it('maps constitution-guard to BeforeTool', () => {
    assert.equal(HOOK_MAP['constitution-guard'].event, 'BeforeTool');
  });

  it('maps read-protection to BeforeTool', () => {
    assert.equal(HOOK_MAP['read-protection'].event, 'BeforeTool');
  });

  it('maps session-digest to PreCompress', () => {
    assert.equal(HOOK_MAP['session-digest'].event, 'PreCompress');
  });

  it('every entry has a description', () => {
    for (const [name, config] of Object.entries(HOOK_MAP)) {
      assert.ok(config.description, `${name} should have a description`);
      assert.ok(config.description.length > 5, `${name} description should be meaningful`);
    }
  });
});

// ---------------------------------------------------------------------------
// generateAllGeminiHooks
// ---------------------------------------------------------------------------

describe('generateAllGeminiHooks', () => {
  const hooks = generateAllGeminiHooks();

  it('generates 6 hook files', () => {
    assert.equal(Object.keys(hooks).length, 6);
  });

  it('generates all expected filenames', () => {
    const expected = [
      'prism-engine.js',
      'model-governance.js',
      'mode-governance.js',
      'constitution-guard.js',
      'read-protection.js',
      'session-digest.js',
    ];
    for (const name of expected) {
      assert.ok(hooks[name], `Should generate ${name}`);
    }
  });

  it('all hooks are non-empty strings', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(typeof content === 'string', `${name} should be a string`);
      assert.ok(content.length > 100, `${name} should be non-trivial`);
    }
  });

  it('all hooks have shebang line', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(content.startsWith('#!/usr/bin/env node'), `${name} should have shebang`);
    }
  });

  it('all hooks have auto-generated header', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(content.includes('Auto-generated by chati.dev'), `${name} should have auto-generated header`);
    }
  });

  it('hooks do not reference Claude-specific APIs', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(!content.includes('PreToolUse'), `${name} should not reference PreToolUse (Claude event)`);
      assert.ok(!content.includes('UserPromptSubmit'), `${name} should not reference UserPromptSubmit (Claude event)`);
      assert.ok(!content.includes('PreCompact'), `${name} should not reference PreCompact (Claude event)`);
    }
  });

  it('mode-governance hook contains MODE_SCOPES', () => {
    assert.ok(hooks['mode-governance.js'].includes('MODE_SCOPES'));
    assert.ok(hooks['mode-governance.js'].includes('planning'));
    assert.ok(hooks['mode-governance.js'].includes('build'));
    assert.ok(hooks['mode-governance.js'].includes('deploy'));
  });

  it('constitution-guard hook contains DESTRUCTIVE_PATTERNS', () => {
    assert.ok(hooks['constitution-guard.js'].includes('DESTRUCTIVE_PATTERNS'));
    assert.ok(hooks['constitution-guard.js'].includes('rm'));
    assert.ok(hooks['constitution-guard.js'].includes('git'));
  });

  it('read-protection hook contains PROTECTED_FILES', () => {
    assert.ok(hooks['read-protection.js'].includes('PROTECTED_FILES'));
    assert.ok(hooks['read-protection.js'].includes('.env'));
    assert.ok(hooks['read-protection.js'].includes('.pem'));
  });

  it('read-protection hook allows safe patterns', () => {
    assert.ok(hooks['read-protection.js'].includes('.env.example'));
    assert.ok(hooks['read-protection.js'].includes('SAFE_FILES'));
  });

  it('session-digest hook references shared hook path', () => {
    assert.ok(hooks['session-digest.js'].includes("'session-digest.js'"),
      'Should reference session-digest.js filename');
    assert.ok(hooks['session-digest.js'].includes("'hooks'"),
      'Should reference hooks directory');
  });

  it('prism-engine hook references shared hook path', () => {
    assert.ok(hooks['prism-engine.js'].includes("'prism-engine.js'"),
      'Should reference prism-engine.js filename');
    assert.ok(hooks['prism-engine.js'].includes("'hooks'"),
      'Should reference hooks directory');
  });
});

// ---------------------------------------------------------------------------
// generateGeminiSettings
// ---------------------------------------------------------------------------

describe('generateGeminiSettings', () => {
  it('returns valid JSON', () => {
    const settings = generateGeminiSettings();
    const parsed = JSON.parse(settings);
    assert.ok(parsed, 'Should parse as JSON');
  });

  it('has hooks as object keyed by event name', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    assert.ok(typeof parsed.hooks === 'object' && !Array.isArray(parsed.hooks),
      'hooks should be an object, not an array');
  });

  it('has 3 event types (BeforeModel, BeforeTool, PreCompress)', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const events = Object.keys(parsed.hooks);
    assert.equal(events.length, 3);
    assert.ok(events.includes('BeforeModel'));
    assert.ok(events.includes('BeforeTool'));
    assert.ok(events.includes('PreCompress'));
  });

  it('BeforeModel group has 2 hooks (prism-engine, model-governance)', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const group = parsed.hooks.BeforeModel[0];
    assert.equal(group.hooks.length, 2);
    const names = group.hooks.map(h => h.name);
    assert.ok(names.includes('prism-engine'));
    assert.ok(names.includes('model-governance'));
  });

  it('BeforeTool group has 3 hooks and a matcher', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const group = parsed.hooks.BeforeTool[0];
    assert.equal(group.hooks.length, 3);
    assert.ok(group.matcher, 'BeforeTool should have a matcher');
    const names = group.hooks.map(h => h.name);
    assert.ok(names.includes('mode-governance'));
    assert.ok(names.includes('constitution-guard'));
    assert.ok(names.includes('read-protection'));
  });

  it('PreCompress group has 1 hook (session-digest)', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const group = parsed.hooks.PreCompress[0];
    assert.equal(group.hooks.length, 1);
    assert.equal(group.hooks[0].name, 'session-digest');
  });

  it('all hooks have type=command and command field', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    for (const [event, groups] of Object.entries(parsed.hooks)) {
      for (const group of groups) {
        for (const hook of group.hooks) {
          assert.equal(hook.type, 'command', `${hook.name} should have type=command`);
          assert.ok(hook.command, `${hook.name} should have command field`);
          assert.ok(hook.command.includes('.gemini/hooks/'), `${hook.name} command should reference .gemini/hooks/`);
        }
      }
    }
  });
});
