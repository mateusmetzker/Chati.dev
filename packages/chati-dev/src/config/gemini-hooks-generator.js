/**
 * @fileoverview Gemini CLI hooks generator.
 *
 * Generates thin wrapper hooks for Gemini CLI that import shared logic
 * from chati.dev/hooks/. Each hook translates between Gemini CLI event
 * format and the existing hook logic, providing governance parity with
 * Claude Code.
 *
 * Constitution Article XIX — hooks are generated at install time, zero runtime overhead.
 *
 * Gemini CLI Hook Events (used by chati.dev):
 * - BeforeModel: runs before model inference (PRISM injection, model advisory)
 * - BeforeTool: runs before tool execution (mode governance, constitution guard, read protection)
 * - PreCompress: runs before context compression (session digest)
 */

// ---------------------------------------------------------------------------
// Hook Map — Claude Hook → Gemini Event
// ---------------------------------------------------------------------------

/**
 * Maps each chati.dev hook to its Gemini CLI equivalent event.
 */
export const HOOK_MAP = {
  'prism-engine': { event: 'BeforeModel', description: 'Inject PRISM context into model prompt' },
  'model-governance': { event: 'BeforeModel', description: 'Advisory: recommended model per agent' },
  'mode-governance': { event: 'BeforeTool', description: 'Block writes outside current mode scope' },
  'constitution-guard': { event: 'BeforeTool', description: 'Block destructive commands and secret writes' },
  'read-protection': { event: 'BeforeTool', description: 'Block reads of sensitive files' },
  'session-digest': { event: 'PreCompress', description: 'Save session state before context compression' },
};

// ---------------------------------------------------------------------------
// Hook Templates
// ---------------------------------------------------------------------------

/**
 * Shared header for all generated hooks.
 */
const HOOK_HEADER = `#!/usr/bin/env node
/**
 * Auto-generated by chati.dev — Gemini CLI hook wrapper.
 * Imports shared logic from chati.dev/hooks/ for governance parity.
 * Do not edit manually — regenerate with \`npx chati-dev init\`.
 */

import { existsSync, readFileSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = join(__filename, '..');
const projectRoot = join(__dirname, '..', '..');
`;

/**
 * Generate the PRISM engine hook for Gemini CLI.
 * BeforeModel event — injects PRISM context XML into the model prompt.
 */
function generatePrismEngine() {
  return `${HOOK_HEADER}
/**
 * PRISM Engine — BeforeModel
 * Reads session state and injects PRISM context block.
 */
async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const cwd = event.cwd || process.cwd();

    const sessionPath = join(cwd, '.chati', 'session.yaml');
    if (!existsSync(sessionPath)) {
      console.log(JSON.stringify({}));
      return;
    }

    // Delegate to shared PRISM engine logic
    const hookPath = join(cwd, 'chati.dev', 'hooks', 'prism-engine.js');
    if (existsSync(hookPath)) {
      const mod = await import(hookPath);
      if (typeof mod.buildPrismContext === 'function') {
        const context = await mod.buildPrismContext(cwd);
        if (context) {
          console.log(JSON.stringify({ additionalContext: context }));
          return;
        }
      }
    }

    console.log(JSON.stringify({}));
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

/**
 * Generate the model governance hook for Gemini CLI.
 * BeforeModel event — advisory about recommended model per agent.
 */
function generateModelGovernance() {
  return `${HOOK_HEADER}
/**
 * Model Governance — BeforeModel
 * Advisory: logs recommended model for current agent.
 */
async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const cwd = event.cwd || process.cwd();

    const sessionPath = join(cwd, '.chati', 'session.yaml');
    if (!existsSync(sessionPath)) {
      console.log(JSON.stringify({}));
      return;
    }

    // Read current agent from session
    const raw = readFileSync(sessionPath, 'utf-8');
    const agentMatch = raw.match(/^\\s*current_agent:\\s*(.+)$/m);
    const agent = agentMatch ? agentMatch[1].trim().replace(/^["']|["']$/g, '') : null;

    if (agent) {
      // Delegate to shared model governance logic
      const hookPath = join(cwd, 'chati.dev', 'hooks', 'model-governance.js');
      if (existsSync(hookPath)) {
        const mod = await import(hookPath);
        if (typeof mod.getRecommendedModel === 'function') {
          const recommendation = mod.getRecommendedModel(cwd, agent);
          if (recommendation) {
            console.log(JSON.stringify({ advisory: \`Recommended model: \${recommendation}\` }));
            return;
          }
        }
      }
    }

    console.log(JSON.stringify({}));
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

/**
 * Generate the mode governance hook for Gemini CLI.
 * BeforeTool event — blocks writes outside the scope of current governance mode.
 */
function generateModeGovernance() {
  return `${HOOK_HEADER}
/**
 * Mode Governance — BeforeTool
 * Blocks write operations outside current mode scope.
 * Constitution Article XI enforcement.
 */
const MODE_SCOPES = {
  planning: { allowed: ['chati.dev/', '.chati/', 'chati.dev/artifacts/'] },
  build: { allowed: ['*'] },
  deploy: { allowed: ['*'] },
};

const STATE_TO_MODE = {
  discover: 'planning', plan: 'planning', planning: 'planning',
  build: 'build', validate: 'build',
  deploy: 'deploy', completed: 'deploy',
};

function getCurrentMode(cwd) {
  const sessionPath = join(cwd, '.chati', 'session.yaml');
  if (!existsSync(sessionPath)) return 'planning';
  const raw = readFileSync(sessionPath, 'utf-8');
  const match = raw.match(/^\\s*state:\\s*(.+)$/m);
  const state = match ? match[1].trim().replace(/^["']|["']$/g, '') : 'discover';
  return STATE_TO_MODE[state] || 'planning';
}

function isPathAllowed(filePath, cwd, mode) {
  const scope = MODE_SCOPES[mode];
  if (!scope) return false;
  if (scope.allowed.includes('*')) return true;

  // Normalize to relative path
  const rel = filePath.startsWith('/') ? filePath.slice(cwd.length + 1) : filePath;

  // Check path escape
  if (rel.startsWith('..') || rel.startsWith('/')) return false;

  return scope.allowed.some(prefix => rel.startsWith(prefix));
}

async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const cwd = event.cwd || process.cwd();
    const toolName = event.tool_name || '';
    const toolInput = event.tool_input || {};

    // Only intercept write/edit operations
    if (!['WriteFile', 'EditFile', 'Write', 'Edit'].includes(toolName)) {
      console.log(JSON.stringify({}));
      return;
    }

    const filePath = toolInput.path || toolInput.file_path || '';
    if (!filePath) {
      console.log(JSON.stringify({}));
      return;
    }

    const mode = getCurrentMode(cwd);
    if (isPathAllowed(filePath, cwd, mode)) {
      console.log(JSON.stringify({}));
    } else {
      console.log(JSON.stringify({
        error: \`[Article XI] Cannot write "\${filePath}" in \${mode} mode. Allowed: \${MODE_SCOPES[mode].allowed.join(', ')}\`
      }));
    }
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

/**
 * Generate the constitution guard hook for Gemini CLI.
 * BeforeTool event — blocks destructive commands and secret writes.
 */
function generateConstitutionGuard() {
  return `${HOOK_HEADER}
/**
 * Constitution Guard — BeforeTool
 * Blocks destructive commands and secret writes.
 * Constitution Article XI enforcement.
 */

const DESTRUCTIVE_PATTERNS = [
  /rm\\s+-rf\\s+\\//,
  /git\\s+reset\\s+--hard/,
  /git\\s+push\\s+--force/,
  /git\\s+push\\s+-f/,
  /git\\s+clean\\s+-fd/,
  /DROP\\s+TABLE/i,
  /DROP\\s+DATABASE/i,
  /TRUNCATE\\s+TABLE/i,
  /chmod\\s+777/,
];

const SECRET_PATTERNS = [
  /API_KEY\\s*=/,
  /SECRET_KEY\\s*=/,
  /PASSWORD\\s*=/,
  /PRIVATE_KEY\\s*=/,
  /aws_secret_access_key/i,
  /-----BEGIN.*PRIVATE KEY-----/,
];

const PROTECTED_WRITE_FILES = ['.env', '.env.local', '.env.production', 'credentials.json', 'service-account.json'];
const SAFE_PATTERNS = ['.env.example', '.env.template', '.env.sample'];

async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const toolName = event.tool_name || '';
    const toolInput = event.tool_input || {};

    // Check Bash commands for destructive patterns
    if (['Bash', 'RunCommand'].includes(toolName)) {
      const cmd = toolInput.command || '';
      for (const pattern of DESTRUCTIVE_PATTERNS) {
        if (pattern.test(cmd)) {
          console.log(JSON.stringify({
            error: \`[Constitution Guard] Blocked destructive command: \${cmd.slice(0, 80)}\`
          }));
          return;
        }
      }
    }

    // Check Write/Edit for secret patterns and protected files
    if (['WriteFile', 'EditFile', 'Write', 'Edit'].includes(toolName)) {
      const filePath = toolInput.path || toolInput.file_path || '';
      const content = toolInput.content || toolInput.new_string || '';

      // Check if writing to a protected file
      if (PROTECTED_WRITE_FILES.some(p => filePath.endsWith(p)) &&
          !SAFE_PATTERNS.some(s => filePath.endsWith(s))) {
        console.log(JSON.stringify({
          error: \`[Constitution Guard] Cannot write to protected file: \${filePath}\`
        }));
        return;
      }

      // Check content for secret patterns
      for (const pattern of SECRET_PATTERNS) {
        if (pattern.test(content)) {
          console.log(JSON.stringify({
            error: '[Constitution Guard] Blocked write containing secrets/credentials'
          }));
          return;
        }
      }
    }

    console.log(JSON.stringify({}));
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

/**
 * Generate the read protection hook for Gemini CLI.
 * BeforeTool event — blocks reads of sensitive files.
 */
function generateReadProtection() {
  return `${HOOK_HEADER}
/**
 * Read Protection — BeforeTool
 * Blocks reading sensitive files (.env, .pem, credentials).
 * Constitution Article XI enforcement.
 */

const PROTECTED_FILES = ['.env', '.env.local', '.env.production', '.env.staging'];
const PROTECTED_EXTENSIONS = ['.pem', '.key', '.p12', '.pfx', '.jks'];
const PROTECTED_PATHS = ['credentials.json', 'service-account.json', '.git/config', '.aws/credentials', '.npmrc'];
const SAFE_FILES = ['.env.example', '.env.template', '.env.sample'];

async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const toolName = event.tool_name || '';
    const toolInput = event.tool_input || {};

    // Only intercept read operations
    if (!['ReadFile', 'Read'].includes(toolName)) {
      console.log(JSON.stringify({}));
      return;
    }

    const filePath = toolInput.path || toolInput.file_path || '';
    if (!filePath) {
      console.log(JSON.stringify({}));
      return;
    }

    // Allow safe patterns first
    if (SAFE_FILES.some(s => filePath.endsWith(s))) {
      console.log(JSON.stringify({}));
      return;
    }

    // Block protected files
    if (PROTECTED_FILES.some(p => filePath.endsWith(p))) {
      console.log(JSON.stringify({
        error: \`[Read Protection] Cannot read protected file: \${filePath}\`
      }));
      return;
    }

    // Block protected extensions
    if (PROTECTED_EXTENSIONS.some(ext => filePath.endsWith(ext))) {
      console.log(JSON.stringify({
        error: \`[Read Protection] Cannot read sensitive file type: \${filePath}\`
      }));
      return;
    }

    // Block protected paths
    if (PROTECTED_PATHS.some(p => filePath.includes(p))) {
      console.log(JSON.stringify({
        error: \`[Read Protection] Cannot read protected path: \${filePath}\`
      }));
      return;
    }

    console.log(JSON.stringify({}));
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

/**
 * Generate the session digest hook for Gemini CLI.
 * PreCompress event — saves session state before context compression.
 */
function generateSessionDigest() {
  return `${HOOK_HEADER}
/**
 * Session Digest — PreCompress
 * Saves session state before context compression.
 */
async function main() {
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  try {
    const event = JSON.parse(input);
    const cwd = event.cwd || process.cwd();

    // Delegate to shared session digest logic
    const hookPath = join(cwd, 'chati.dev', 'hooks', 'session-digest.js');
    if (existsSync(hookPath)) {
      const mod = await import(hookPath);
      if (typeof mod.saveDigest === 'function') {
        await mod.saveDigest(cwd);
      }
    }

    console.log(JSON.stringify({}));
  } catch {
    console.log(JSON.stringify({}));
  }
}

main();
`;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Generate all 6 Gemini CLI hook files.
 *
 * @returns {Record<string, string>} Map of filename → file content
 */
export function generateAllGeminiHooks() {
  return {
    'prism-engine.js': generatePrismEngine(),
    'model-governance.js': generateModelGovernance(),
    'mode-governance.js': generateModeGovernance(),
    'constitution-guard.js': generateConstitutionGuard(),
    'read-protection.js': generateReadProtection(),
    'session-digest.js': generateSessionDigest(),
  };
}

/**
 * Generate .gemini/settings.json content with hook configuration.
 *
 * Gemini CLI expects hooks as an object keyed by event name, where each
 * event contains an array of hook groups. Each group has an optional
 * `matcher` and a `hooks` array with `{ name, type, command }` entries.
 *
 * @returns {string} JSON string for .gemini/settings.json
 */
export function generateGeminiSettings() {
  // Group hooks by event
  const eventGroups = {};
  for (const [name, config] of Object.entries(HOOK_MAP)) {
    if (!eventGroups[config.event]) {
      eventGroups[config.event] = [];
    }
    eventGroups[config.event].push({
      name,
      type: 'command',
      command: `node .gemini/hooks/${name}.js`,
      description: config.description,
    });
  }

  // Build the settings object: each event → array of hook groups
  const hooks = {};
  for (const [event, hookList] of Object.entries(eventGroups)) {
    // Tool events (BeforeTool) use matcher; lifecycle events don't
    const isToolEvent = event.includes('Tool');
    hooks[event] = [
      {
        ...(isToolEvent ? { matcher: '.*' } : {}),
        hooks: hookList,
      },
    ];
  }

  return JSON.stringify({ hooks }, null, 2) + '\n';
}
